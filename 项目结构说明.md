# 医疗知识图谱问答系统 - 项目结构说明

**作者**：医疗知识图谱问答系统——何阳  
**日期**：2025-12-20

## 📁 项目整体结构

```
QASystemOnMedicalKG-master/
├── chat_with_llm.py          # RAG问答系统主程序（基于LLM，命令行界面）
├── qwen7b_server.py          # Qwen LLM服务端（Flask API + Web可视化界面）
├── llm_server.py            # LLM API客户端封装
├── chatbot_graph.py         # 传统规则问答系统（可选）
├── question_classifier.py   # 问题分类器（实体识别）
├── question_parser.py      # 问题解析器（生成Cypher查询）
├── answer_search.py        # 答案搜索器（传统方式）
├── build_medicalgraph.py    # 知识图谱构建脚本
├── data/
│   └── medical.json        # 医疗知识数据（JSON格式）
├── dict/                    # 词典文件目录
│   ├── disease.txt         # 疾病词典
│   ├── symptom.txt         # 症状词典
│   ├── drug.txt            # 药品词典
│   ├── food.txt            # 食物词典
│   ├── check.txt           # 检查项目词典
│   ├── department.txt      # 科室词典
│   ├── producer.txt        # 生产商词典
│   └── deny.txt            # 否定词词典
├── prepare_data/           # 数据准备脚本（可选）
│   ├── data_spider.py     # 数据爬虫
│   ├── build_data.py       # 数据构建
│   └── max_cut.py          # 最大切分算法
└── Qwen-7B-Chat/           # Qwen模型文件（自动下载）
```

## 🔄 系统工作流程

### RAG问答流程（推荐使用）

```
用户问题 
  ↓
[实体识别] question_classifier.py
  ↓ (识别医疗实体)
[知识检索] chat_with_llm.py -> recall_facts()
  ↓ (检索知识图谱三元组)
[LLM生成] qwen7b_server.py (Qwen-1.8B-Chat)
  ↓ (基于三元组生成答案)
最终答案
```

### 传统规则问答流程（可选）

```
用户问题 
  ↓
[问题分类器] question_classifier.py
  ↓ (识别实体 + 问题类型)
[问题解析器] question_parser.py  
  ↓ (生成Cypher查询语句)
[答案搜索器] answer_search.py
  ↓ (执行查询 + 格式化答案)
最终答案
```

## 📝 核心模块详解

> **注意**：所有核心代码文件都已添加详细的中文注释，包括：
> - 文件头部说明（功能、接口、作者信息）
> - 类和函数的详细文档字符串
> - 关键代码行的行内注释
> - 参数和返回值的说明

### 1. **chat_with_llm.py** - RAG问答系统主程序（推荐）

**作用**：基于知识图谱检索增强生成（RAG）的问答系统

**主要功能**：
- 实体识别与链接（使用AC自动机）
- 知识图谱三元组检索（优先选择直接相关的三元组）
- 调用LLM生成答案（基于检索到的三元组）

**关键类**：
```python
class KGRAG:
    """
    知识图谱检索增强生成（KGRAG）类
    
    功能：
    1. 实体识别：从用户问题中识别医疗实体（疾病、症状等）
    2. 知识检索：从Neo4j知识图谱中检索相关三元组
    3. 答案生成：基于检索到的知识，使用LLM生成答案
    """
    def entity_linking(self, query)      # 实体识别与链接
    def link_entity_rel(self, ...)       # 获取实体相关的属性字段列表
    def recall_facts(self, ...)          # 从知识图谱中检索相关三元组
    def format_prompt(self, ...)         # 构建用于LLM生成的prompt
    def chat(self, query)                # 主问答流程（RAG三步骤）
```

**工作流程**：
1. Step1: 识别问题中的医疗实体（疾病、症状等）
2. Step2: 从知识图谱检索相关三元组（最多50条）
3. Step3: 将三元组和问题拼接成prompt，调用LLM生成答案

---

### 2. **qwen7b_server.py** - LLM服务端 + Web可视化界面

**作用**：提供Flask API服务和Web可视化界面，封装Qwen-1.8B-Chat模型

**主要功能**：
- 加载Qwen-1.8B-Chat模型
- 提供 `/generate` API接口（基础LLM生成）
- 提供 `/rag` API接口（完整RAG问答，可选）
- 提供Web可视化界面（访问根路径 `/`）
- 支持GPU/CPU模式自动切换
- 显存优化（限制输入长度、清理缓存）

**API接口**：
- GET `/`：Web可视化界面（美观的问答界面）
  - 返回HTML页面，用户可在浏览器中直接使用
  - 支持示例问题快速填入
  - 实时显示答案，界面友好
- POST `/generate`：基础LLM生成接口
  - 接收JSON格式：`{"message": [{"content": "问题"}], "max_tokens": 256}`
  - 返回：`{"output": ["答案"], "status": "success"}`
- GET `/generate?q=问题`：快速测试接口
- POST `/rag`：完整RAG问答接口（如果RAG模块可用）
  - 接收JSON格式：`{"question": "问题"}` 或 `{"q": "问题"}`
  - 先检索知识图谱，再生成答案，比基础接口更准确

**Web界面特点**：
- 🎨 美观的渐变背景和卡片式设计
- 💡 输入框直接输入问题
- 📋 提供示例问题，点击即可快速填入
- ✨ 实时显示答案，界面友好
- 🔄 支持Ctrl+Enter快捷键提交

**配置**：
- 默认端口：3001
- 默认模型：Qwen/Qwen-1_8B-Chat
- 支持GPU（fp16）和CPU（fp32）模式
- Web界面自动调用RAG接口（如果可用）

---

### 3. **llm_server.py** - LLM API客户端

**作用**：封装对LLM服务的HTTP请求

**主要功能**：
- 发送HTTP请求到LLM服务
- 处理超时和错误重试（最多重试10次）
- 支持历史对话（history）
- 支持自定义最大生成长度（max_tokens）

**关键方法**：
```python
class ModelAPI:
    """
    LLM API客户端类
    
    用于与Qwen LLM服务端进行HTTP通信
    """
    def __init__(self, MODEL_URL)        # 初始化，设置服务URL
    def send_request(self, message, history, max_tokens)  # 发送HTTP请求
    def chat(self, query, history, max_tokens)  # 对话接口，支持自动重试
```

**特点**：
- 超时时间设置为120秒（考虑CPU推理较慢）
- 自动处理HTTP错误和JSON解析错误
- 失败后自动重试，提高稳定性

---

### 4. **chatbot_graph.py** - 传统规则问答系统（可选）

**作用**：整个问答系统的入口和协调器

**主要功能**：
- 初始化三个核心组件（分类器、解析器、搜索器）
- 协调整个问答流程
- 提供交互式命令行界面

**关键代码**：
```python
class ChatBotGraph:
    def __init__(self):
        self.classifier = QuestionClassifier()  # 问题分类器
        self.parser = QuestionPaser()           # 问题解析器
        self.searcher = AnswerSearcher()        # 答案搜索器
    
    def chat_main(self, sent):
        # 1. 分类问题
        res_classify = self.classifier.classify(sent)
        # 2. 解析问题，生成查询
        res_sql = self.parser.parser_main(res_classify)
        # 3. 搜索答案
        final_answers = self.searcher.search_main(res_sql)
        return '\n'.join(final_answers)
```

---

### 5. **question_classifier.py** - 问题分类器

**作用**：识别问题中的医疗实体，并判断问题类型

**主要功能**：
- **实体识别**：从问题中提取医疗实体（疾病、症状、药品、食物等）
- **问题分类**：根据疑问词和实体类型，判断问题属于18种类型中的哪一种

**技术特点**：
- 使用 **AC自动机（Aho-Corasick）** 算法快速匹配实体
- 加载7类医疗实体词典（疾病、症状、药品、食物、检查、科室、生产商）
- 定义疑问词模板（症状、原因、并发症、饮食、药品等）

**支持的18种问题类型**：
1. `disease_symptom` - 疾病症状（如：乳腺癌的症状有哪些？）
2. `symptom_disease` - 症状查疾病（如：最近老流鼻涕怎么办？）
3. `disease_cause` - 疾病病因（如：为什么有的人会失眠？）
4. `disease_acompany` - 疾病并发症
5. `disease_not_food` - 疾病忌吃食物
6. `disease_do_food` - 疾病宜吃食物
7. `food_not_disease` - 食物忌吃疾病
8. `food_do_disease` - 食物宜吃疾病
9. `disease_drug` - 疾病用药
10. `drug_disease` - 药品治什么病
11. `disease_check` - 疾病检查项目
12. `check_disease` - 检查项目查疾病
13. `disease_prevent` - 预防措施
14. `disease_lasttime` - 治疗周期
15. `disease_cureway` - 治疗方式
16. `disease_cureprob` - 治愈概率
17. `disease_easyget` - 易感人群
18. `disease_desc` - 疾病描述

**关键方法**：
- `check_medical()`: 使用AC自动机从问题中提取医疗实体
- `classify()`: 根据疑问词和实体类型分类问题
- `build_actree()`: 构建AC自动机，加速实体匹配

---

### 6. **question_parser.py** - 问题解析器

**作用**：将分类后的问题转换为Neo4j的Cypher查询语句

**主要功能**：
- 根据问题类型和实体，生成对应的Cypher查询
- 支持18种问题类型，每种类型对应不同的查询模式

**查询示例**：

**疾病症状查询**：
```cypher
MATCH (m:Disease)-[r:has_symptom]->(n:Symptom) 
WHERE m.name = '乳腺癌' 
RETURN m.name, r.name, n.name
```

**疾病用药查询**：
```cypher
MATCH (m:Disease)-[r:common_drug]->(n:Drug) 
WHERE m.name = '肝病' 
RETURN m.name, r.name, n.name
```

**关键方法**：
- `parser_main()`: 主解析函数，根据问题类型调用相应的查询生成
- `sql_transfer()`: 为每种问题类型生成对应的Cypher查询语句

---

### 7. **answer_search.py** - 答案搜索器

**作用**：执行Cypher查询，并将结果格式化为自然语言答案

**主要功能**：
- 连接Neo4j数据库
- 执行Cypher查询语句
- 根据问题类型，使用不同的模板格式化答案

**关键方法**：
- `search_main()`: 执行查询并收集结果
- `answer_prettify()`: 根据问题类型，使用模板格式化答案

**答案格式化示例**：
- 输入：`disease_symptom` + 查询结果
- 输出：`乳腺癌的症状包括：乳腺组织肥厚；胸痛；乳头溢液...`

---

### 8. **build_medicalgraph.py** - 知识图谱构建器

**作用**：从JSON数据文件构建Neo4j知识图谱

**主要功能**：
- 读取 `data/medical.json` 文件
- 解析7类实体节点（疾病、症状、药品、食物、检查、科室、生产商）
- 创建11类关系边（症状、并发症、用药、饮食、检查等）
- 将数据导入Neo4j数据库

**知识图谱结构**：

**节点类型（7类）**：
- `Disease` - 疾病（包含属性：name, desc, cause, prevent, cure_way等）
- `Symptom` - 症状
- `Drug` - 药品
- `Food` - 食物
- `Check` - 检查项目
- `Department` - 科室
- `Producer` - 生产商

**关系类型（11类）**：
- `has_symptom` - 疾病-症状关系
- `acompany_with` - 疾病-并发症关系
- `common_drug` - 疾病-常用药品关系
- `recommand_drug` - 疾病-推荐药品关系
- `do_eat` - 疾病-宜吃食物关系
- `no_eat` - 疾病-忌吃食物关系
- `recommand_eat` - 疾病-推荐食谱关系
- `need_check` - 疾病-检查项目关系
- `belongs_to` - 疾病-科室关系 / 科室-科室关系
- `drugs_of` - 生产商-药品关系

**关键方法**：
- `read_nodes()`: 读取JSON文件，解析实体和关系
- `create_graphnodes()`: 创建所有节点
- `create_graphrels()`: 创建所有关系边

---

## 🗂️ 数据文件说明

### `data/medical.json`
- 格式：每行一个JSON对象
- 内容：包含疾病及其相关信息的结构化数据
- 字段：name, desc, cause, prevent, symptom, acompany, drug, food, check等

### `dict/` 目录
包含7类医疗实体的词典文件，用于实体识别：
- `disease.txt` - 疾病名称列表
- `symptom.txt` - 症状名称列表
- `drug.txt` - 药品名称列表
- `food.txt` - 食物名称列表
- `check.txt` - 检查项目列表
- `department.txt` - 科室列表
- `producer.txt` - 生产商列表
- `deny.txt` - 否定词列表（用于区分"宜吃"和"忌吃"）

---

## 🔧 技术栈

- **Python 3.7+**
- **Neo4j** - 图数据库，存储知识图谱
- **py2neo** - Neo4j的Python客户端
- **pyahocorasick** - AC自动机算法，用于快速实体匹配
- **Transformers** - HuggingFace库，用于加载Qwen模型
- **Flask** - Web框架，提供LLM API服务
- **PyTorch** - 深度学习框架，运行Qwen模型
- **Qwen-1.8B-Chat** - 通义千问1.8B对话模型

---

## 🚀 运行流程

### RAG问答系统（推荐）

1. **构建知识图谱**（首次运行）：
   ```bash
   python build_medicalgraph.py
   ```
   - 从 `data/medical.json` 读取数据
   - 创建节点和关系
   - 导入到Neo4j数据库

2. **启动LLM服务**（终端1）：
   ```bash
   python qwen7b_server.py
   ```
   - 加载Qwen-1.8B-Chat模型
   - 启动Flask服务（端口3001）
   - **保持运行**

3. **使用RAG问答系统**（两种方式）：
   
   **方式1：Web可视化界面（推荐）⭐**
   - 在浏览器中访问：`http://127.0.0.1:3001/`
   - 使用美观的Web界面进行问答
   - 无需命令行操作
   
   **方式2：命令行界面**
   ```bash
   python chat_with_llm.py
   ```
   - 启动交互式命令行问答界面
   - 输入问题，系统自动检索知识图谱并生成答案

### 传统规则问答系统（可选）

```bash
python chatbot_graph.py
```

---

## 💡 设计亮点

### RAG问答系统
1. **检索增强生成**：结合知识图谱的结构化知识和大语言模型的生成能力
2. **智能检索**：优先选择与目标实体直接相关的三元组，避免不相关信息
3. **显存优化**：针对6GB GPU进行了优化，支持长文本输入和生成
4. **可解释性**：通过调试信息可以看到三元组检索过程，了解答案来源
5. **模块化设计**：实体识别、知识检索、答案生成三个模块职责清晰
6. **Web可视化界面**：提供美观的Web界面，无需命令行操作，直接在浏览器中使用，提升用户体验
7. **代码规范**：所有核心代码文件都添加了详细的中文注释，包括：
   - 文件头部说明（功能、接口、作者信息）
   - 类和函数的详细文档字符串
   - 关键代码行的行内注释
   - 参数和返回值的说明

### 传统规则系统
1. **模块化设计**：分类、解析、搜索三个模块职责清晰
2. **规则驱动**：基于词典和规则的问题分类，无需训练模型
3. **AC自动机**：高效的实体匹配算法
4. **Cypher查询**：灵活的知识图谱查询
5. **模板化答案**：不同问题类型使用不同的答案模板

---

## 📊 知识图谱规模

- **实体数量**：约4.4万（疾病、症状、药品、食物等）
- **关系数量**：约30万（各种实体间的关系）
- **实体类型**：7类
- **关系类型**：11类

---

**项目维护者**：何阳  
**最后更新**：2025-12-20  
**代码说明**：所有核心代码文件都已添加详细的中文注释，包括文件说明、函数文档、参数说明等，便于学习和二次开发

